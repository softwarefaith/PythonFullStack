

"""
函数基本理论:

定义函数时，需要确定函数名和参数个数；

如果有必要，可以先对参数的数据类型做检查；isinstance()

函数体内部可以用return随时返回函数结果；

函数执行完毕也没有return语句时，自动return None。

函数可以同时返回多个值，但其实就是一个tuple。

"""


"""
一是必选参数在前，默认参数在后，否则Python的解释器会报错

二是如何设置默认参数。

当函数有多个参数时，把变化大的参数放前面，变化小的参数放后面。
变化小的参数就可以作为默认参数。

使用默认参数有什么好处？最大的好处是能降低调用函数的难度。(偏函数应用)

"""


def python_function(name, age, address='BJ'):
    print('name:', name, 'age:', age, 'address:', address)

python_function('cai', 27)

python_function(age=30, address='SH', name='Allan')


"""
   默认参数的坑:代码如下
   
   产生原因: 
   Python函数在定义的时候，默认参数L的值就被计算出来了，即[]，因为默认参数L也是一个变量，它指向对象[]，每次调用该函数，
   如果改变了L的内容，则下次调用时，默认参数的内容就变了，不再是函数定义时的[]了。
     所以，定义默认参数要牢记一点：默认参数必须指向不变对象！
     用None这个不变对象
     
     默认参数一定要用不可变对象，如果是可变对象，运行会有逻辑错误！
"""


def add(l=[]):
    l.append('end')
    return l


print('第一次调用:', add())
print("第二次调用", add(), )


""" 
1.可变参数:
允许你传入0个或任意个参数，这些可变参数在函数调用时自动组装为一个tuple
*args 会把多传入的参数变成一个元组形式tuple

2.关键字参数:
允许你传入0个或任意个含参数名的参数，这些关键字参数在函数内部自动组装为一个dict。
**kv
可以扩展函数的功能

3.组合参数
在Python中定义函数，可以用必选参数、默认参数、可变参数和关键字参数，
这4种参数都可以一起使用，或者只用其中某些，
但是请注意，参数定义的顺序必须是：必选参数、默认参数、可变参数和关键字参数。

4.神奇函数:
对于任意函数，都可以通过类似func(*args, **kw)的形式调用它，无论它的参数是如何定义的。

"""


def more_function(name, age, *args):
    print('name:', name, 'age:', age, 'arg:', args)

more_function('Allan', 50, 'BJ', 'SH')


def more_key_function(name, age, **kv):
    print('name:', name, 'age:', age, 'arg:', kv)

more_key_function("Allan", 30, school='BJ', country='China')


"""
递归函数:
一个函数在内部调用自身本身，这个函数就是递归函数

递归函数的优点是定义简单，逻辑清晰。
理论上，所有的递归函数都可以写成循环的方式，但循环的逻辑不如递归清晰。

使用递归函数需要注意防止栈溢出。

在计算机中，函数调用是通过栈（stack）这种数据结构实现的，
每当进入一个函数调用，栈就会加一层栈帧，
每当函数返回，栈就会减一层栈帧。
由于栈的大小不是无限的，所以，递归调用的次数过多，会导致栈溢出。

解决递归调用栈溢出的方法是通过尾递归优化，事实上尾递归和循环的效果是一样的.

尾递归是指，在函数返回的时候，调用自身本身，并且，return语句不能包含表达式 
换句话说:return selffucntion。
这样，编译器或者解释器就可以把尾递归做优化，
使递归本身无论调用多少次，都只占用一个栈帧，不会出现栈溢出的情况

Python标准的解释器没有针对尾递归做优化，任何递归函数都存在栈溢出的问题。


"""


"""
匿名函数****
"""

calc=lambda a, b: a * b

print(calc(2, 4))

